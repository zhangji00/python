import time

def sliceentrys(acontent, parser=None):
 index = 0
 entrys = []
 while True:
  nextstart = acontent.find("(", index)
  if nextstart == -1:
   break
  index = nextstart
  nextend = acontent.find(")", index)
  if nextend == -1:
   break
  index = nextend
  entry = acontent[nextstart+1:nextend]
  data = entry.split(",")
  if parser!=None:
    data = parser(data)
  entrys.append(data)
 return entrys

def sliceentrysf(acontent, parser=None):
 index = 0
 entrys = []
 while True:
  nextstart = acontent.find("{", index)
  if nextstart == -1:
   break
  index = nextstart
  nextend = acontent.find("}", index)
  if nextend == -1:
   break
  index = nextend
  entry = acontent[nextstart+1:nextend]
  data = entry.split("-")
  entrys = (int(data[0]), int(data[1]))
 return entrys

def loadtrack(filename, parser=None):
  k = open(filename,"r").read()
  index = 0
  result = {}
  result2 = {}
  while index < len(k):
   tagstart = k.find("[", index)
   if tagstart == -1:
    break
   index = tagstart
   tagend = k.find("]", index)
   if tagend == -1:
    break
   index = tagend + 1
   tag = k[tagstart+1: tagend]
   end = k.find("@", index)
   if end == -1:
    break
   content = k[index: end]
   index = end
   data = sliceentrys(content, parser)
   frames = sliceentrysf(content)
   if frames != []:
    result2[int(tag)] = frames
    print frames
   result[int(tag)] = data
  return (result, result2)

(track0,ign) = loadtrack("data/a.dat")
(track1,ign) = loadtrack("data/b.dat")
(track2,ign) = loadtrack("data/c.dat")
(track3,ign) = loadtrack("data/d.dat")

def scriptparser(x):
    x[0] = int(x[0])
    x[1] = int(x[1])
    x[2] = int(x[2])
    x[3] = int(x[3])
    x[4] = int(x[4])
    x[5] = int(x[5])
    return x

(scriptdata,ign) = loadtrack("data/100.dat", parser=scriptparser)

def swatchparser(x):
    x[0] = int(x[0])
    x[1] = int(x[1])
    x[2] = int(x[2])
    return x

(randswatch,ign) = loadtrack("data/200_1.dat", parser=swatchparser)

def lineupparser(x):
    x[0] = int(x[0])
    x[1] = int(x[1])
    return x

(lineups,lineupstime) = loadtrack("data/300_1.dat", parser=lineupparser)

class FishBase(object):
  def __init__ (self, ftype, tracktype, trackid, groupid, subid, xoffset = 0, yoffset = 0):
    self.current_frame = 0
    self.trackid = trackid
    self.ftype = ftype
    if track0.has_key(trackid):
        self.track = track0
    if track1.has_key(trackid):
        self.track = track1
    if track2.has_key(trackid):
        self.track = track2
    if track3.has_key(trackid):
        self.track = track3
    if tracktype == 1:
      if track1.has_key(trackid):
          self.track = track1
      
    self.tracklen = len(self.track[trackid])
    self.xoffset = xoffset
    self.yoffset = yoffset
    self.groupid = groupid
    self.subid = subid
  def update(self):
    if self.current_frame + 1 >= self.tracklen:
      return False
    else:
      self.current_frame += 1
      return True
  def getPos(self):
    trackpos = self.track[self.trackid][self.current_frame]
    return (int(trackpos[0])+self.xoffset, int(trackpos[1])+self.yoffset)

class FishGroup(object):
    def __init__(self, id, scriptid):
        self.id = id
        self.scriptid = scriptid
        self.curframe = 0
        self.subid = 0
        #maxframe?
    def update(self, game):
        self.curframe += 1
        for scriptframe in scriptdata[self.scriptid]:
            if scriptframe[2] == self.curframe:
                self.subid += 1
                print("GROUP: create fish", self.subid, 
                    scriptframe[1], 
                    scriptframe[3],
                    scriptframe[4],
                    scriptframe[5])
                game.create_fish(
                    ftype=scriptframe[1], 
                    tracktype=scriptframe[0],
                    trackid=scriptframe[3],
                    groupid = self.id,
                    subid = self.subid,
                    isgroup=1,
                    xoffset = scriptframe[4],
                    yoffset = scriptframe[5])


class SwatchRand(object):
    def __init__(self, game, id):
        self.game = game
        self.id = id
        self.count = len(randswatch[id])
        self.last = 0
    def update(self, curframe):
        #print("last, new",self.last, self.count)
        for i in range(self.last, self.count):
            data = randswatch[self.id][i]
            if data[1] > curframe:
                break
            if data[1] == curframe:
                ftype = data[0]
                if ftype == 100:
                    self.game.create_group(
                        groupid=i, 
                        scriptid=data[2])
                else:
                    print("create fish", i,  data[1], ftype, data[2])
                    self.game.create_fish(
                                ftype=data[0], 
                                tracktype=0,
                                trackid=data[2],
                                groupid=i,
                                subid = 0
                                )
            self.last = i+1

class LineUp(object):
    def __init__(self, game, id):
        self.game = game
        self.id = id
        self.count = len(lineups[id])
        self.last = 0
        (st, lineup_time) = lineupstime[self.id]
        self.lineup_time = lineup_time
    def update(self, curframe):
        #print("last, new",self.last, self.count)
        if curframe > self.lineup_time:
          return False
        for i in range(self.last, self.count):
            data = lineups[self.id][i]
            if data[1] == curframe:
                self.game.create_group(
                    groupid=i + 50001,
                    scriptid=data[0])

class GameView(object):
    def __init__(self):
        self.fishes = []
        self.groups = []
        self.curframe = 0
        self.lineup = None
        self.randswatch = None
        self.lastupdate = time.time() 
        self.selected = None

    def create_fish(self, ftype, tracktype, trackid, groupid, subid, isgroup=0, isbig=0, yoffset = 0, xoffset = 0):
        newfish = FishBase(
                    ftype = ftype,
                    tracktype = tracktype,
                    trackid =trackid, 
                    groupid=groupid,
                    subid=subid,
                    xoffset=xoffset, 
                    yoffset=yoffset)
        newfish.isgroup = isgroup
        newfish.isbig = isbig
        self.fishes.append(newfish)

    def create_group(self, groupid, scriptid):
        print("create group", groupid,  scriptid)
        newgroup = FishGroup(groupid, scriptid)
        self.groups.append(newgroup)

    def setparams(self, randswatchid, lineupid, ptime):
      self.fishes = []
      self.groups = []
      self.randswatch = None
      self.lineup = None
      (st, lineup_time) = lineupstime[lineupid]
      self.randswatch = SwatchRand(self, randswatchid)
      self.lineup = LineUp(self, lineupid)
      self.curframe = ptime + lineup_time

    def getfish(self, id, subid, type):
      for onefish in self.fishes:
        if onefish.groupid == id and onefish.subid == subid:
          return onefish
      return None

    def update(self):
      frames = (time.time() - self.lastupdate) * 1000 / 50
      if frames > 0:
        self.lastupdate = self.lastupdate + 0.050  * frames
        for frame in range(0,int(frames)):
          self.doframe()

    def doframe(self):
      self.lastupdate = time.time()
      self.curframe += 1
      if self.lineup != None:
          ret = self.lineup.update(self.curframe)
          if ret == False:
            self.curframe = self.curframe - self.lineup.lineup_time
            self.lineup = None
      else:
          if self.randswatch != None:
              self.randswatch.update(self.curframe)

      for onefish in list(self.fishes):
          if onefish.update() == False:
            self.fishes.remove(onefish)

      for onegroup in self.groups:
          onegroup.update(self)


class TollGate(object):
    def __init__(self, tgid, lineupid, curframe):
        self.tgid = tgid
        self.lineupid = lineupid
        self.curframe = curframe
    def update(self):
        pass
    def getall(self):
        pass
