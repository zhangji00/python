# iptables -t nat -A PREROUTING -s 192.168.1.123/32 -d 120.55.248.157/32 -p tcp -j REDIRECT --to-ports 9001
# iptables -t nat -A PREROUTING -s 192.168.1.123/32 -d 121.43.187.2 -p tcp -j REDIRECT --to-ports 9001
# iptables -t nat -A PREROUTING -s 192.168.1.123/32 -d 172.28.0.214 -p tcp -j REDIRECT --to-ports 9001
# iptables -t nat -A PREROUTING -s 192.168.1.123/32 -d 1.1.1.1/32 -p tcp -j REDIRECT --to-ports 9001
#iptables -t nat  -A PREROUTING -s 192.168.1.0/24 -p tcp -m tcp --dport 80 -j ACCEPT
#iptables -t nat  -A PREROUTING -s 192.168.1.123/32 -p tcp -m tcp ! --dport 443 -j REDIRECT --to-ports 9001
#iptables -t nat  -A PREROUTING -s 192.168.1.123/32 -p tcp -m tcp --dport 80 -j ACCEPT


#iptables -t nat  -A PREROUTING -s 192.168.1.0/24 -p tcp -m tcp --dport 80 -j ACCEPT
#iptables -t nat  -A PREROUTING -s 192.168.1.0/24 -p tcp -m tcp --dport 443 -j ACCEPT
#iptables -t nat  -A PREROUTING -s 192.168.1.0/24 -p tcp -m tcp -j REDIRECT --to-ports 9001

import socket
import select
import time
import sys

import datetime
import binascii
from struct import *
import struct
#from cryptography.hazmat.primitives.ciphers.algorithms import SEED

import asyncore, socket
import requests
import ssl

import re

import xml.etree.ElementTree as ET

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import random

import threading

import fishgame



def animate_game_fish(i):
    global game

    game.update()
    #pullData = open("sampleText.txt","r").read()
    ax1.clear()
    ax1.set_ylim([-100,600])
    ax1.set_xlim([-100,1010])
    time_text = ax1.text(0.05, 0.9, 'frame %d' % (game.curframe), transform=ax1.transAxes)

    xar2 = []
    yar2 = []
    colors = []
    areas = []
    for onefish in list(game.fishes):
        (x,y) = onefish.getPos()
        color = 0.1
        area = 6
        if (onefish.ftype == 61) or (onefish.ftype == 2):
            color = 0.5
        if ((onefish.ftype == 39) or (onefish.ftype == 32) 
                or (onefish.ftype == 31)
                or (onefish.ftype == 27)
                or (onefish.ftype == 23)
                or (onefish.ftype == 19)
                or (onefish.ftype == 58)
                or (onefish.ftype == 40)
                ):
            area = 9
            color = 0.9
        if onefish == game.selected:
          color = 0.7

        areas.append(area)
        xar2.append(x)
        yar2.append(y)
        colors.append(color)


    area = np.pi * np.array(areas)**2  # 0 to 15 point radiuses

    ax1.scatter(xar2, yar2, s=area, c=colors, alpha=0.7)

game = fishgame.GameView()
game.setparams(2, 2, 1339)


# Changing the buffer_size and delay, you can improve the speed and bandwidth.
# But when buffer get to high or delay go too down, you can broke things
buffer_size = 4096
delay = 0.0001

#mu port is 2100x
#forward_to = ('120.132.76.117', 21001)


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    

def step1(originalport, data):
    connect=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    connect.connect(("121.43.187.2",originalport))

    print "generator called", repr(data)

    connect.sendall(data)
    rdata = connect.recv(4096)

    print "generator received", repr(rdata)

    return '\x03\x01\x000\x03\x0c\x00\x00\x00\x00\x00\x00\xef\xcd\xab\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x01\xf1\xbd\x00\x00\xac\x1c\x00)\xf1\xbd\x00\x00'

def step2(originalport, data):
    print "step2", repr(data)
    if data[3] == chr(0x50):
        a='\x03\x01\x00,\x01\n\x00\x00\x01\x00\x00\x00\xef\xcd\xab\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x003T(W'
        a+='\x03\x01\x00$!\x00\x00\x00\x01\x00\x00\x00\xef\xcd\xab\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf1\xbd\x00\x00\x05\x00\x00\x00'
        a+='\x03\x01\x008"\x00\x00\x00\x01\x00\x00\x00\xef\xcd\xab\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        return a

    if data[3] == chr(0x24):
        return '\x03\x01\x00(\x02\n\x00\x00\x01\x00\x00\x00\xef\xcd\xab\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00'


def print_hex_string_nicely(hex_string):
    index = 0
    result = ''
    while hex_string:
        result += '{:08x}: '.format(index)
        index += 16
        line, hex_string = hex_string[:32], hex_string[32:]
        while line:
            two_bytes, line = line[:4], line[4:]
            if two_bytes:
                result += two_bytes + ' '
        result = result[:-1] + '\n'
    print result

def replace_invalid2(x):
    if ord(x) < 32 or ord(x)>129:
        return "."
    else: 
        return x

def replace_invalid(packet_data):
    return "".join([replace_invalid2(a) for a in packet_data])

def hex_dump_packet(packet_data):
    print_hex_string_nicely(binascii.hexlify(packet_data))
    print(repr(packet_data))

def print_http(packet_data):
    if packet_data.find("\x0d\x0a\x0d\x0a") > -1:
        packet_data = packet_data[packet_data.index("\x0d\x0a\x0d\x0a") + 4:]
    print_hex_string_nicely(binascii.hexlify(packet_data))
    print(repr(packet_data))

def print_it(x):
    print repr(x)

def sendinit(dataend):
            a='\x03\x01\x004k\x00#\x00F\x00\x00\x00\x00\x14\x14\x14\x0c\x1e2dddn\x82\x96\x96\x96\x00\x00\x00\x00\x00\x1e\x1e\x1e\x1e\x1e\x0f\x0f\x0f\x0f\x0f\x1e2Fd\x96\x01\x01\x00\x00\x00'
            dataend.send(a)

            a='\x03\x01\x00D\x130\x00\x00\x00\x00\x00\x00\x00\x00\r\x00\x00\x00\x00\x00zT\x1a\x04\xd9*\x00\x00\n\x00\x00\x00C\x19\x00\x00\xe6\xb8\xb8\xe5\xae\xa268834426\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x01\x00D\x13$\x00\x00\x01\x00\x00\x00\x00\x00\x16\x00\x00\x00\x00\x00\xad\xca\xb8\x03\xad7\x00\x00\x13\x00\x00\x00@\xe8\x00\x00\xe6\xb8\xb8\xe5\xae\xa262442157\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x01\x00D\x13\x00\x00\x00\x02\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00I\xa6\x1b\x04k\x04\x00\x00"\x00\x00\x00u\x1b\x00\x00\xe6\xb8\xb8\xe5\xae\xa268920905\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
            dataend.send(a)
            #'03010044133000000000000000000d00000000007a541a04d92a00000a00000043190000e6b8b8e5aea23638383334343236000000000000000000000000000000000000'
            #'0301004413240000010000000000160000000000adcab803ad3700001300000040e80000e6b8b8e5aea23632343432313537000000000000000000000000000000000000'
            #'030100441300000002000000000008000000000049a61b046b04000022000000751b0000e6b8b8e5aea23638393230393035000000000000000000000000000000000000'

            #original
            a = """03 01 01 38 02 05 1c 4d 02 01 33 2d 00 00 00 00 00 00 
            0a 
            00 00 00 00 00 
            e2 e8 f7 03 43 25 00 00 
            0b 00 00 00 
            a0 15 00 00 e6 b8 b8 e5 ae a2 36 36 35 37 38 36 35 38 
            000000000000000000000000000000000000
            03050000f20200000000000000000000

            59010000000000004a8a010000000000
            62010000000000006401000000000000
            66010000000000004b8a010000000000
            67010000000000006901000000000000
            6a010000000000006b01000000000000
            6d010000000000004c8a010000000000
            6e010000000000007001000000000000
            71010000000000007201000000000000
            73010000000000007401000000000000
            75010000000000007601000000000000
            77010000000000004c01000000400000
            5c010000dc1f00005f01000040000000
            63010000060000006501000002000000
            68010000030000006c0100001f000000"""

            #1440 5600
            #deterministic state...
            #like it may be spawning a wave based on a random seed
            #probably a big ammount of waves is scripted
            #and probably there is a random seed
            #its posible that the behaviors are scripted in lua
            #this is the time on the script
            #this is a script with a long pattern for different waves of groups
            #we can derivate the current ids based on other players hitting fishes
            #by numeric analisys can derivate many ids, from  a few

            #tollgate_id << 2 + appstate [06] 
            # [02] [4d]
            #mainframe lineup [02 01] 
            #framecounter [00 00] 
            
            a = """03 01 01 38 02 
            [06] 
            [02 4d]
            [02 02] 
            [00 00] 
            [00 00] 00 00 00 00 
            08 
            00 00 00 00 00 
            e2 e8 f7 03 
            [43 25 00 00 ]
            0c 00 00 00 
            a0 
            [15 00] 00 
            [e6 b8 b8 e5 ae a2 36 36 35 37 38 36 35 38] 
            000000000000000000000000000000000000
            03050000 f2 0200000000000000000000

            4a8a0100 00000000
            6201000000000000
            59010000 00000000

            
            6401000000000000
            6601000000000000
            4b8a010000000000
            6701000000000000
            6901000000000000
            6a01000000000000
            6b01000000000000
            6d01000000000000
            4c8a010000000000
            6e01000000000000
            7001000000000000
            7101000000000000
            7201000000000000
            7301000000000000
            7401000000000000
            7501000000000000
            7601000000000000
            7701000000000000
            4c01000000000000
            5c010000dc1f0000
            5f01000040000000
            6301000006000000
            6501000002000000
            6801000000000000
            6c01000000000000"""
            
            # 00000000: 0300 0034 0601 7500 0000 0000 0000 0000
            # 00000010: 0000 0000 0000 0000 5ccf d430 5cc5 d430
            # 00000020: 5ccd d430 5cd1 d430 5cd3 d430 5cd5 d430
            # 00000030: 5c03 d630

            #can try to follow when it creates special fishes from this array

            #for every scene will need to determine the fish ids
            #they will probably be generated in deterministic way
            
            #1 way is to get the memory structures of the fish, 
            #and capture for every scene ids
            #the objetive is to be able to enumerate all the fish present on the screen

            #then analize numbers, one way, is to crack the generating algorithm just by observation, if lucky...
            
            #need try to get to the generator of the fishes

            a=a.replace("[", "")
            a=a.replace("]", "")
            a=a.replace("\t", "")
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            """
            a = '03 01 01 60 [68] 2b 00 01 05 20 2b 00 00 00 e8 0d 38 40 2c 00 00 00 10 0a 16 802c000000940807c02c00000038073de02c00000020060f202d000000c40512402d000000c40538602d000000c40538a02d000000b00505c02d000000d00305002e000000a00116202e000000980116402e000000140139602e000000140117802e000000140139a02e000000100116c02e00000004013de02e000000b40057832b0000002008528f290000001c0857842b00000054070c622c000000300757852b0000008c0654e72b000000c00502a22c000000580557872b000000fc0404812d000000f80404822d000000f80404832d000000f80404842d000000f80404852d000000f8040c632c000000d80440012d000000ac0457882b000000340457892b0000006c03578a2b000000a40240022d0000005402578b2b000000dc0152e12d0000003401578c2b000000140152e22d0000006c00578d2b0000004c0002012f0000003800'

            a=a.replace("[", "")
            a=a.replace("]", "")
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            a = '0301001c15209e2a0e0000004a8a0100000000000400000000000000'
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            a = '0301001c1521672b170000004b8a0100000000000400000000000000'
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            a = '0301001c1546302c1e0000004c8a0100000000000800000000000000'
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            a = '0301001474000300f92a0a003c2803003e280200'
            
            a=a.replace("\r", "")
            a=a.replace("\n", "")
            a=a.replace(" ", "")
            a = binascii.unhexlify(a)
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06\xc3\x05\x00\xad7\x00\x00\x00\x00\n\x00\t\x00\x13\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05\xc4\x1dI'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05_\xa0\x80'
            dataend.send(a)

            a = '\x03\x00\x00\x0c\t\xc9\x00\x00\n\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x0c\t\xc9\x00\x00\n\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06_\x06\x00j\x04\x00\x00\x00\x00\x01\x00\x00\x00"\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06\xc4\x05\x00\xa37\x00\x00\x00\x00\n\x00\t\x00\x13\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05\x15\x85\x0c'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05\xc5\x19I'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05`\xa7\x80'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06\xc5\x05\x00\x997\x00\x00\x00\x00\n\x00\t\x00\x13\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06`\x06\x00i\x04\x00\x00\x00\x00\x01\x00\x00\x00"\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06\x15\x04\x00\xc0*\x00\x00\x00\x00\x19\x00\x0c\x00\n\x00\x00\x00\x00\x00'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05\x16\x82\x0c'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05a\xa7\x80'
            dataend.send(a)

            a = '\x03\x01\x00\x08\x05\xc6\x96I'
            dataend.send(a)

            a = '\x03\x01\x00\x18\x06\x16\x04\x00\xa7*\x00\x00\x00\x00\x19\x00\x0c\x00\n\x00\x00\x00\x00\x00'
            dataend.send(a)

            a ='\x03\x01\x00\x18\x06a\x06\x00h\x04\x00\x00\x00\x00\x01\x00\x00\x00"\x00\x00\x00\x00\x00'
            dataend.send(a)
            """

bulletid = 0

import struct

class Buffer:
    def __init__(self):
        self.bytes = ""
    def add(self, data):
        self.bytes += data
    def getnext(self):
        if len(self.bytes) < 4:
            return None
        (nextsize,) = struct.unpack_from(">h", self.bytes, 2)
        if len(self.bytes) < nextsize:
            return None
        ret = self.bytes[:nextsize]
        self.bytes = self.bytes[nextsize:]
        return ret
    def nextsize(self):
        (nextsize,) = struct.unpack_from(">h", self.bytes, 2)
        return nextsize

class Channel:
    def __init__(self, sin, sout, virtual=None, generator=None, printer=print_it):
        self.sin = sin
        self.sout = sout
        self.initialized = False
        self.virtual = virtual
        self.generator = generator
        self.printer = printer
        self.bin = Buffer()
        self.bout = Buffer()

    def get_otherend(self, myend):
        if myend == self.sout:
            return self.sin
        else:
            return self.sout

    def procdata(self, dataend, data):
        global gameconnection, bulletid
        if dataend == self.sout:
            buff = self.bout
            otherend = self.sin
        else:
            buff = self.bin
            otherend = self.sout
        
        if self.virtual != None:
            if re.match("^(GET|POST|PUT|DELETE|HEAD) .* HTTP/1.1", data):
                k = data.split("\r\n")
                a = k[0].split(" ")
                a[1] = self.virtual[0](a[1])
                k[0] = " ".join(a)
                for a in range(0,len(k)):
                    if k[a].find("Host:") == 0:
                        k[a] = "Host: " + self.virtual[1]
                data = "\r\n".join(k)
                print "modified data!"

        if self.printer != None:
            #self.printer(data)
            pass

        if self.generator != None:
            print "feeding generated data"
            d = self.generator(self.port, data)
            print d
            dataend.send(d)
            return
        #00000000: 0300 0028 0601 4700 0000 0000 0000 0000
        #00000010: 0000 0000 0000 0000 5cab d630 5848 d630
        #00000020: 584c d630 5850 d630
        if (dataend == self.sout):
                print(repr(data))

        buff.add(data)
        while True:
            packet = buff.getnext()
            if packet == None:
                break
            doprint = True
            opcode = ord(packet[4])
            if opcode == 6 and len(packet) == 0x18:
                doprint = False
            if opcode == 5:
                doprint = False
            if doprint:
                print_hex_string_nicely(binascii.hexlify(packet))
            if (dataend == self.sin) and (opcode == 2):
                time = (ord(packet[11]) << 8) + ord(packet[10])
                rswatch = ord(packet[8])
                rlineup = ord(packet[9])
                print("setparams", rswatch, rlineup, time)
                if rswatch != 0 and rlineup!=0:
                    game.setparams(rswatch, rlineup, 0)
                    for a in range(0, time):
                      game.doframe()
                print("loginres:", binascii.hexlify(packet))

        #03010128 02 11[1a49][0304][cb2e]

        #\x03\x00\x00\x08\x05\x81\xa0\xcc
        if (dataend == self.sout) and (ord(data[4]) == 5):
            ndata = [ord(a) for a in data]
            bulletid = ndata[5]
            multiplier = 5
            for i in range(0,multiplier):
                ndata[5] = bulletid * multiplier + i
                ndata[5] = ndata[5] % 250
                if ndata[5] != 0:
                    print("sending bullet", ndata[5])
                    if otherend != None:
                        otherend.send(bytearray(ndata))
            return
        if (dataend == self.sout) and (ord(data[4]) == 6):
                print("orig",binascii.hexlify(bytearray(data)))
                (p,) = struct.unpack_from("<I",data, 0x18)
                groupid = p >> 14
                subid = (p & ((1 << 14) - 1)) >> 9
                fishtype = (p & ((1 << 9) - 1)) >> 2
                print(groupid, subid, fishtype, game.getfish(groupid, subid, fishtype))

                ndata = [ord(a) for a in data]
                if True:
                    fid = ndata[0x18]
                    ndata[6] = (ndata[6] & 0xf) + (0x1 << 4)
                    ndata[3] = 0x18 + (4 * 10)
                    ndata = ndata + [0] * ((0x18 + 10 * 4) - len(ndata))
                    for a in range(0,10):
                        ndata[0x18 + a*4] = ndata[0x18]
                        ndata[0x19 + a*4] = ndata[0x19]
                        ndata[0x1a + a*4] = ndata[0x1a]
                        ndata[0x1b + a*4] = ndata[0x1b]
                    print(binascii.hexlify(bytearray(ndata)))
                    ndata = bytearray(ndata)
                mbulletid = ndata[5]
                multiplier = 5
                for i in range(0,multiplier):
                    ndata[5] = (mbulletid * multiplier) + i
                    ndata[5] = ndata[5] % 250
                    if ndata[5] != 0:
                        print("sending hit", ndata[5] )
                        if otherend != None:
                            otherend.send(bytearray(ndata))
                return

        if (dataend == self.sout) and (data.find('\x03\x00\x00$\x01\x00\x00\x00') == 0) and False:
            self.sin = None
            gameconnection = dataend
            print 'probably game connection'

            sendinit(dataend)
            return

        if otherend != None:
            otherend.send(data)

import urlparse

class Forward:
    def __init__(self):
        self.forward = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def start(self, host, port):
        try:
            self.forward.connect((host, port))
            return self.forward
        except Exception, e:
            print e
            return False

SO_ORIGINAL_DST = 80
class TheServer:
    input_list = []
    channel = {}
    counter = None

    def __init__(self, host, port):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.bind((host, port))
        self.server.listen(200)

    def main_loop(self):
        self.input_list.append(self.server)
        while 1:
            time.sleep(delay)
            ss = select.select
            inputready, outputready, exceptready = ss(self.input_list, [], [])
            for self.s in inputready:
                if self.s == self.server:
                    self.on_accept()
                    break

                try:
                    self.data = self.s.recv(buffer_size)
                except:
                    self.on_close()
                    break

                if len(self.data) == 0:
                    self.on_close()
                    break
                else:
                    self.on_recv()

    #got from pr0cks project https://github.com/n1nj4sec/pr0cks/blob/master/pr0cks.py
    def get_destipport(self, sock):
        odestdata = sock.getsockopt(socket.SOL_IP, SO_ORIGINAL_DST, 16)
        _, port, a1, a2, a3, a4 = struct.unpack("!HHBBBBxxxxxxxx", odestdata)
        address = "%d.%d.%d.%d" % (a1, a2, a3, a4)
        print('[+] Forwarding incoming connection from %s to %s through the proxy' % (repr(sock.getpeername()), (address, port)))
        return (address, port)
        


    def on_accept(self):
        clientsock, clientaddr = self.server.accept()
        forward_to = self.get_destipport(clientsock)

        virtual = None
        printer = None
        #printer = print_it

        printer = hex_dump_packet

        if forward_to[1] == 80:
            printer = print_http

        if forward_to[1] != 9090:
            forward = Forward().start(forward_to[0], forward_to[1])
        else:
            forward = None

        
        if forward:
            print clientaddr, "has connected"
            self.input_list.append(clientsock)
            self.input_list.append(forward)
            nchannel = Channel(forward, clientsock, virtual, printer=printer)
            self.channel[clientsock] = nchannel
            self.channel[forward] = nchannel
        else:
            print "Can't establish connection with remote server.",
            print "Closing connection with client side", clientaddr
            clientsock.close()

    def on_close(self):
        
        try:
            name = self.s.getpeername()
        except:
            name = "unknown"
        print name, "has disconnected"

        chan = self.channel[self.s]

        otherend = chan.get_otherend(self.s)

        myend =  chan.get_otherend(otherend)
        if myend == None:
            self.input_list.remove(self.s)
            # close the connection with remote server
            self.s.close()
            return

        #remove objects from input_list
        self.input_list.remove(self.s)
        # close the connection with remote server
        self.s.close()
        # delete both objects from channel dict
        del self.channel[self.s]

        if otherend != None:
            self.input_list.remove(otherend)
            # close the connection with client
            otherend.close()  # equivalent to do self.s.close()
            del self.channel[otherend]

    def on_recv(self):
        data = self.data

        #print "got some data"
        # here we can parse and/or modify the data before send forward
        #hex_dump_packet(data)
            
        self.channel[self.s].procdata(self.s, data)

def servthread():
    server = TheServer('', 9001)
    try:
        server.main_loop()
    except KeyboardInterrupt:
        print "Ctrl C - Stopping server"
        sys.exit(1)

def onclick(event):
    #print('button=%d, x=%d, y=%d, xdata=%f, ydata=%f' %
    #      (event.button, event.x, event.y, event.xdata, event.ydata))
    v = (99999999999, None)
    for onefish in game.fishes:
        (x,y) = onefish.getPos()
        dx = x - event.xdata
        dy = y - event.ydata
        dist = (dx*dx) + (dy*dy)
        #print(v[0], dist)
        if v[0] > dist:
          v = (dist, onefish)
    if None != v[1]:
      (x,y) = v[1].getPos()
      print(v[1].groupid, v[1].subid, v[1].ftype, x,y, event.x, event.y)
      game.selected = v[1]

if __name__ == '__main__':
    t = threading.Thread(target=servthread)
    t.setDaemon(True)
    t.start()

    fig = plt.figure()
    ax1 = fig.add_subplot(111)

    cid = fig.canvas.mpl_connect('button_press_event', onclick)

    ani = animation.FuncAnimation(fig, animate_game_fish, blit=False,\
         interval=50, repeat=True)

    plt.show()
    print "have a good day"
    sys.exit(0)
